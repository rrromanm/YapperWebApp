@using DTOs.Models
@using HttpClients.ClientInterfaces
@inject ICommentService CommentService
@inject ISMUserService SMUserService
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject NavigationManager NavigationManager

<div class="comments-container">
    @if (commentsWithUsers != null && commentsWithUsers.Count > 0)
    {
        @foreach (var commentWithUser in commentsWithUsers)
        {
            <div class="comment-item">
                <p><strong class="username-link" @onclick="() => NavigateToUserProfile(commentWithUser.User.Username)">@commentWithUser.User.Nickname:</strong> @commentWithUser.Comment.body</p>
                <small class="text-muted">@commentWithUser.Comment.commentDate</small>
                <div class="like-section">
                    <button class="like-button" @onclick="() => ToggleLikeComment(commentWithUser.Comment.commentId, commentWithUser.Comment.userLiked)">
                        <i class="@LikeIconClass(commentWithUser.Comment.userLiked)"></i> @LikeText(commentWithUser.Comment.userLiked) (@commentWithUser.Comment.likeCount)
                    </button>
                    @if (commentWithUser.Comment.userId == CurrentUserId)
                    {
                    <button class="delete-button" @onclick="() => DeleteComment(commentWithUser.Comment.commentId)">
                        <i class="bi bi-trash"></i> Delete
                    </button>
                    }
                </div>
            </div>
        }
    }
    else
    {
        <p>No comments available.</p>
    }
</div>

@code {
    [Parameter] public int PostId { get; set; }
    [Parameter] public EventCallback OnCommentDeleted { get; set; }
    private List<CommentWithUser> commentsWithUsers;
    private int CurrentUserId { get; set; }
    
    private string LikeText(bool userLiked) => userLiked ? "Unlike" : "Like";
    private string LikeIconClass(bool userLiked) => userLiked ? "bi bi-hand-thumbs-up-fill" : "bi bi-hand-thumbs-up";
    private string LikeButtonClass(bool userLiked) => userLiked ? "btn-primary" : "btn-outline-primary";

    protected override async Task OnParametersSetAsync()
    {
        await LoadCommentsAndUsers();
        await FetchLikedComments();
    }

    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;

        if (user.Identity.IsAuthenticated)
        {
            var userId = user.Claims.FirstOrDefault(c => c.Type == "Id")?.Value;
            CurrentUserId = int.Parse(userId);
            await LoadCommentsAndUsers();
            await FetchLikedComments();
        }
    }

    private async Task LoadCommentsAndUsers()
    {
        try
        {

            var comments = await CommentService.GetCommentsByPostIdAsync(PostId);


            var tasks = comments.Select(async comment => new CommentWithUser
            {
                Comment = comment,
                User = await SMUserService.GetByUserId(comment.userId)
            });

            commentsWithUsers = (await Task.WhenAll(tasks)).ToList();

        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading comments for PostId {PostId}: {ex.Message}");
        }
    }

    private async Task LikeComment(int commentId)
    {
        try
        {
            await CommentService.LikeCommentAsync(commentId, CurrentUserId);
            var comment = commentsWithUsers.FirstOrDefault(c => c.Comment.commentId == commentId);
            if (comment != null)
            {
                comment.Comment.likeCount++;
                comment.Comment.userLiked = true;
            }
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error liking comment {commentId}: {ex.Message}");
        }
    }
    private async Task UnlikeComment(int commentId)
    {
        try
        {
            await CommentService.UnlikeCommentAsync(commentId, CurrentUserId);
            var comment = commentsWithUsers.FirstOrDefault(c => c.Comment.commentId == commentId);
            if (comment != null)
            {
                comment.Comment.likeCount--;
                comment.Comment.userLiked = false;
            }
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error unliking comment {commentId}: {ex.Message}");
        }
    }
    private async Task ToggleLikeComment(int commentId, bool userLiked)
    {
        if (userLiked)
        {
            await UnlikeComment(commentId);
        }
        else
        {
            await LikeComment(commentId);
        }

        await ReloadCommentsAsync();
    }

    private async Task FetchLikedComments()
    {
        try
        {
            var likedComments = await CommentService.GetAllLikedCommentsAsync(CurrentUserId);
            foreach (var comment in commentsWithUsers)
            {
                comment.Comment.userLiked = likedComments.Any(c => c.commentId == comment.Comment.commentId);
            }
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
            throw;
        }
    }

    private class CommentWithUser
    {
        public Comment Comment { get; set; }
        public User User { get; set; }
    }
    private void NavigateToUserProfile(string username)
    {
        NavigationManager.NavigateTo($"/Profiles/{username}");
    }
    public async Task ReloadCommentsAsync()
    {
        await LoadCommentsAndUsers();
        await FetchLikedComments();
        StateHasChanged();
    }

    private async Task DeleteComment(int commentId)
    {
        try
        {
            await CommentService.DeleteCommentAsync(commentId);
            await ReloadCommentsAsync();
            
            await OnCommentDeleted.InvokeAsync(); // EventCallback to notify PostComponent that comment is deleted
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error deleting comment {commentId}: {ex.Message}");
        }
    }
}